/*
    В некотором устройстве хранения информации используются 6-битные перфоленты.
    6 бит данных достаточно для хранения 64 символов. Цифры '0' - '9' кодируются на перфоленте кодами 1 - 10,
    далее идут строчные латинские буквы 'a' - 'z' (в алфавитном порядке), далее идут коды заглавных латинских букв 'A' - 'Z' 
    в алфавитном порядке). Коды 0 и 63 зарезервированы.

    К сожалению, устройство чтения перфолент оказалось частично неисправным. Считыватель бита с номером 3 испортился
    и вместо наличия отверстия показывает ее отсутствие, а вместо отсутствия — наличие. Считыватель бита 2 засорился и
    всегда показывает отсутствие отверстия. По содержимому ленты, записанному в виде последовательности символов
    в кодировке ASCII, определите последовательность символов, которая будет прочитана неисправным устройством чтения.

    Input format
        На стандартном потоке ввода задаются символы, записанные на ленте. Для представления символов
        используется кодировка ASCII. Поток символов завершается признаком конца файла. В потоке символов все символы,
        не являющиеся латинскими заглавными или строчными буквами или цифрами должны игнорироваться.

    Output format
        На стандартный поток вывода выведите последовательность символов, которая будет прочитана неисправным
        устройством чтения. Для вывода используйте кодировку ASCII. Для вывода кода 0 перфоленты используйте символ '@',
        а для вывода кода 63 - символ '#'.

    См. ./tasks/2.html
*/

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

enum
{
    ARR_SIZE = 64
};

int main(void) {
    char arr[] = "@0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ#\0";

    int c;

    while ((c = getc(stdin)) != EOF) {
        if (isalpha(c) || (c >= '0' && c <= '9')) {
            int k;
            if (islower(c)) {
                k = c - 'a' + ('9' - '0' + 2);
            } else if (c <= '9') {
                k = c - '0' + 1;
            } else {
                k = c + ('9' - '0') + ('z' - 'a') - 'A' + 3;
            }

            k &= ~(1 << 2);
            k ^= (1 << 3);

            putchar(arr[k]);
        }
    }

    return 0;
}
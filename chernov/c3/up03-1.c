/*
    Напишите функцию bit_reverse со следующим прототипом на Си:

    STYPE bit_reverse(STYPE value);

    Где STYPE — это некоторый целый знаковый тип. Кроме того, определен тип UTYPE — это некоторый целый беззнаковый
    тип того же размера, что и STYPE.

    Функция меняет порядок бит в числе на противоположный. Например, рассмотрим 4-битное целое число 0101.
    Поменяв порядок бит на противоположный, получим число 1010. Однако, если то же число рассматривать как 8-битное,
    обратный порядок бит будет равен 10100000.

    Отрицательные числа представляются в дополнительном коде.

    В решении запрещается использовать константы и константные выражения, дающие в качестве результата битность типа,
    например, 32, sizeof (value) * CHAR_BIT и аналогичные.
*/

STYPE bit_reverse(STYPE value) {
    UTYPE mask = ~(UTYPE)0;
    int cnt = 0;
    while (mask != 0) {
        cnt++;
        mask >>= 1;
    }

    cnt--;
    UTYPE res = 0;
    UTYPE u_value = (UTYPE)value;
    while (u_value != 0) {
        res |= (u_value & 1) << cnt;
        cnt--;
        u_value >>= 1;
    }

    return (STYPE)res;
}
